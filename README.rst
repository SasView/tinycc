TinyCC compiler bundle
======================

TinyCC (or tcc) is a small, fast C compiler capable of compiling python
extensions that can be loaded as python modules or producing DLLs that
can be loaded via ctypes.  This version includes compilers for 32-bit and
64-bit Windows.  MacOS and Linux are not supported in this release.

Compiler version: 0.9.26 2013-02-16

Installation of the compiler and the python interface is simply::

    pip install tinycc

Full documentation for the compiler is available at `<http://bellard.org/tcc>`_.
Source and binaries are available from `<https://savannah.nongnu.org/projects/tinycc/>`_.
The tinycc python package is hosted at `<https://github.com/SasView/tinycc>`_.

*TCC* is the full path to the tcc.exe executable. Note that the executable
path may contain spaces so it must be wrapped in quotes when used as part
of an os.system command.

*TCC_VERSION* is the compiler version.

Python extension
~~~~~~~~~~~~~~~~

Adding tinycc as a compiler option to setup.py::

    import tinycc.distutils

When this is done, then you can build your project with::

    python setup.py build --compiler=tinycc

Note that tinycc does not support C++ so it cannot be used a replacement
for MS Visual C++ for Python or mingw as generic compiler for python
installs.

Also note that the compiler does not fully support C99, and some constructs
which compile (e. g., returning a structure from a function call) may not
work in properly.  Be sure to test thoroughly before setting tinycc as a
recommended compiler for your python package.

Shared library
~~~~~~~~~~~~~~

Building a DLL::

    from tinycc import compile
    dll_path = compile("hello.c")

This creates "hello.dll" in the same directory as "hello.c", raising
RuntimeError if the compile fails.  The exception contains the compiler
output.  Use *compile(source, target)* to control the path to the dll.

For more flexibility, you can call the compiler directly::

    import os
    import subprocess
    from tinycc import TCC

    source, target = "hello.c", "hello.dll"
    command = [TCC, "-shared", "-rdynamic", "-Wall", source, "-o", target]
    try:
        # need shell=True on windows to keep console box from popping up
        subprocess.check_output(command, shell=True, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as exc:
        raise RuntimeError("compile failed.\n%s\n%s"%(command_str, exc.output))
    if not os.path.exists(target):
        raise RuntimeError("compile failed.  File is in %r"%source)

Use *data_files* to gather the data files required for bundling tinycc
in a py2exe package.  This places the compiler in the tinycc-data directory
beside the library.zip generated by py2exe.  The following should appear in
the setup.py for the py2exe build::

    import tinycc

    data_files = []
    ...
    data_files.extend(tinycc.data_files())
    ...
    setup(
        ...
        data_files = data_files,
        ...
        )

Note: if you have put tcc.exe somewhere unusual (i.e., not in the tinycc
package and not in tinycc-data next to the py2exe generated library or exe),
then you can set the environment variable TCC_ROOT to the directory
containing tcc.exe.

Release Notes
~~~~~~~~~~~~~

2017-11-20 R 1.1

* support distutils build of python packages

2016-05-31 R 1.0.2

* support build of DLLs for windows 32 and windows 64
